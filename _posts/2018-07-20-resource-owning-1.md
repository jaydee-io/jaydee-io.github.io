---
layout: post
title: "Resource owning - Part 1 : Rule of three"
published: true
tag: [C++]
---
I've seen too much code base mixing technical code with business one. Particulary, a lot of business code is owning technical resource. Trying to figure out what this code does is often a lot of pain. The resource owning code deserve its own class, independent of the business code. This is a good programming practice, well described in the [Separation Of Concern](https://en.wikipedia.org/wiki/Separation_of_concerns) principle. In this post, we will see what are the good rules of thumb to design a resource owning class, starting with the _Rule of three_.

This post is the first part of a series about _Resource owning_:

* [Resource owning - Part 1 : _Rule of three_]({{ site.baseurl }}{% post_url 2018-07-20-resource-owning-1 %})
* Resource owning - Part 2 : _Rule of five_
* Resource owning - Part 3 : _Rule of zero_

Let's start with a good use case : _The circular buffer_

## Use case: _The circular buffer_
Let's say we have to write an application that process data packet coming from network, a serial line or whatever input interface. After few minutes of reflexion, we come up with a design consisting in two parts. The first one is responsible for fetching a chunk of data from the physical interface and for forwarding it to the second part, which will do all the business processing related to this data packet. To effectively manage these data packets, we opted for a big circular buffer, allocated just once, which can store several packets. So, in accordance to the separation of concern principle, the circular buffer ressource deserve its own class. Let's name it `Buffer` for code brevity.

{% highlight C++ linenos %}
class Buffer
{
public:
    explicit Buffer(size_t capacity);
    ~Buffer(void);

    bool isEmpty(void) { ... }
    bool isFull(void) { ... }

    void write(const uint8_t * data, size_t size) { ... }
    void read (      uint8_t * data, size_t size) { ... }

private:
    uint8_t * data;
    size_t    capacity;
    int       start;
    int       end;
};
{% endhighlight %}

This is a simple basic implementation of a circular buffer. The `data` points to a heap allocated buffer of `capacity` bytes. `start` and `end` are indexes used to delimit the occupied part of the buffer. The listing above shows the implementation of the constructor and desctructor. 

{% highlight C++ linenos %}
explicit Buffer(size_t _capacity = 0)
: data(_capacity ? new uint8_t[_capacity] : nullptr)
, capacity(_capacity)
, start(-1)
, end(-1)
{ }

~Buffer(void)
{
    delete [] data;
}
{% endhighlight %}

The buffer capacity is passed as argument to the constructor and used to dynamically allocate the underlying `data` buffer. Other members are initialized so that the buffer is in a valid _empty_ state. Obviously, we free the `data` buffer in the destructor.

But what if we would copy this buffer ? What about the copy construction and the copy assignment ?

## The rule of three
In our case, the copy constructor and copy assignment operator automaticaly generated by the compiler won't do the job. They will just copy the pointer value of `data`. And when the first `Buffer` will be destroyed, the second one will point to a freed memory, which is a _Really Bad Thing_ <sup class="far fa-trademark"></sup>.
So when talking about resource owning, the first good rule of thumb is given by the **Rule of three** :

> If a class requires a user-defined destructor, a user-defined copy constructor, or a user-defined copy assignment operator, it almost certainly requires all three.
{:.blockquote .yoda}

So here we go for the copy constructor:

{% highlight C++ linenos %}
Buffer::Buffer(const Buffer & buffer)
: data(buffer.capacity ? new uint8_t[buffer.capacity] : nullptr)
, capacity(buffer.capacity)
, start(buffer.start)
, end(buffer.end)
{
    std::copy_n(buffer.data, capacity, data);
}
{% endhighlight %}

The `data` of the newly created buffer is allocated with the same capacity as the copied buffer. Then, the buffer content is copied using `std::copy_n()` from the standard library. Other members are also copied. 

Now for the copy assignment operator:

{% highlight C++ linenos %}
Buffer & Buffer::operator =(const Buffer & buffer)
{
    // Prevent self assignment
    if(&buffer != this)
        return *this;

    // Cleanup old data
    delete [] data;

    // Allocate new one
    data     = buffer.capacity ? new uint8_t[buffer.capacity] : nullptr;
    capacity = buffer.capacity;
    start    = buffer.start;
    end      = buffer.end;
    std::copy_n(buffer.data, capacity, data);

    return *this;
}
{% endhighlight %}

The code is pretty straight forward:
* First (lines 4 to 5), we need to prevent from self assignment... Code like `Buffer b; b = b;` won't go well otherwise.
* Next (line 8), we cleanup the current buffer by freeing `data`.
* Finally (lines 11 to 15), we copy the passed buffer, like we did in the copy constructor.

Obviously, don't forget to return a reference to the current buffer in order to allow usage like `Buffer a, b, c; a = b = c`.

This implementation raises some remarks. First, self assignment is very very rare, so the test on line 4 will be false most of the time. Executing useless code 99.99% of the time isn't very pleasant. And secondly, the rest of the code is a duplication of destructor and copy constructor, which violates the [Don't Repeat Yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) principle.

But don't worry, we will fix that in the next part of the series: "_Resource owning - Part 2 : Rule of five_".

## Conclusion
Today, we saw that when talking about resource owning there are some good pratices to use. [Separation Of Concern](https://en.wikipedia.org/wiki/Separation_of_concerns) principle should be applied to separate the resource handling code from the business one. Also, if one of destructor, copy constructor or copy assignment operator is defined, all of them must also be defined, as stated by the [Rule of three](https://en.cppreference.com/w/cpp/language/rule_of_three).
